---
description: "A manager",
alwaysApply: false
---
## InSpatial Documentation Reference

**Core Signal APIs:**

- `createSignal(value)`, `computed(fn)`, `$(fn)` - Creating signals
- `watch(effect)`, `createEffect(effect, ...args)` - Effects with lifecycle
- `read(value)`, `write(signal, value)`, `peek(value)`, `poke(signal, value)` - Utilities
- Signal methods: `.and()`, `.or()`, `.eq()`, `.gt()`, `.inverse()`, `.nullishThen()`, `.hasValue()`
- Advanced: `merge()`, `derive()`, `extract()`, `tpl\`...\``, `not()`, `onCondition()`

Note: hasValue returns plain boolean. Returns true when the value of the signal is not nullish.

**Component (Kit) APIs:**

- `createComponent()`, `web.render(container, component, props, ...children)`, `dispose()` - Component lifecycle
- `expose()`, `capture()`, `snapshot()`, `getCurrentSelf()` - Context management
- `onDispose()` - Cleanup registration

**Built-in Components:**

- `<Show when={} true={} else={}>` - Conditional rendering
- `<List each={} track="" indexed={}>` - List rendering with reconciliation (Direct item access, auto-handles arrays/signals)
- `<Async future={} fallback={} catch={}>` - Promise handling
- `<Dynamic is={}>` - Dynamic component/tag rendering
- `<Fn ctx={} catch={}>` - Function execution with error boundaries

**Renderer Setup:**

- `DOMRenderer(InTrigger)` from `@in/dom`
- `InTrigger` from `@inspatial/kit/trigger` to ship the default/core web props i.e `class:` and `style:`
- Trigger system & Event handling: `on:event`, `on-once:event`, `on-passive:event`, `on-capture:event`

**JSX Configuration**

## Globally defined JSX Runtime for Deno

JSX runtime is essential when using InSpatial together with runtimes like [Deno](https://github.com/denoland/deno/issues/29584), compilers like [SWC](https://github.com/swc-project/swc/issues/10553) or generators like [MDX](https://mdxjs.com/), since they lack the ability to correctly transform JSX via parameters.

### 10. Building for Dev & Production

You can build your app for dev and production using different tools like (InSpatial `Serve` extension, Vite, Rollup with Babel, Rspack or Webpack). InSpatial provides different plugins and extensions for different tools.

- InServe (Default)
- InVite
- InPack

#### InServe (Founders Choice)

When using `InServe()` extension there's no need to use or configure a build tool like Vite or RSPack. To use `InServe()`, create your render.ts file and add it as an extension.

```typescript
// render.ts
import { createRenderer } from "@inspatial/kit/renderer";
import { InServe } from "@in/serve";

createRenderer({
  extensions: [InServe()],
});
```

Then add your deno.json

```json
//deno.json
{
  "tasks": {
    "serve": "deno run --allow-net --allow-read --allow-write --allow-env --allow-run src/config/render.ts"
  }
}
```

#### InVite

Use `InVite` plugin for Vite. Create a `vite.config.ts` file and add the following conifguration

##### Pragma Config (Default)

```typescript
import { defineConfig } from "vite";
import { InVite } from "@in/vite";

export default defineConfig({
  server: {
    port: 6310,
  },
  esbuild: {
    jsxFactory: "R.c",
    jsxFragment: "R.f",
  },
  plugins: [InVite()],
  build: {
    target: "esnext",
  },
});
```

##### Automatic Config

```typescript
import { defineConfig } from "vite";

export default defineConfig({
  esbuild: {
    jsx: "automatic",
    jsxImportSource: "@inspatial/kit", // This tells Vite/esbuild where to find the runtime
  },
});
```

#### Babel (`.babelrc.json`)

```json
{
  "presets": [
    [
      "@babel/preset-react",
      {
        "runtime": "automatic",
        "importSource": "@inspatial/kit"
      }
    ]
  ]
}
```

#### InPack

Use the `InPack` plugin for Webpack and/or RSPack/RSBuild

```javascript
import { defineConfig } from "@rsbuild/core";
import InPack from "@in/pack";

export default defineConfig({
  plugins: [InPack()],
  // ... jsx config
});
```

### Initialization

Once your build tool is configured, you need to initialize the runtime with a renderer in your application's entry point. There are two ways you can configure the renderer.

#### Automatic Render (Preferred)

```typescript
import "./kit.css";
import { createRenderer } from "@inspatial/kit/renderer";
import { App } from "../my/app/root.tsx";

// Create InSpatial renderer with Trigger Props
createRenderer({
  mode: "auto",
  debug: "verbose",
  extensions: [InTrigger],
}).then((InSpatial: any) => {
  InSpatial.render(document.getElementById("app"), App);
});
```

Now, any `.jsx` or `.tsx` file will be automatically transformed to use the initialized runtime, so you don't need any special imports to write JSX.

**Hot Reload:**

---

## ⚠️ CRITICAL: THIS IS NOT REACT!

**DO NOT write React code in this project.** InSpatial has fundamentally different patterns:

### Key Differences from React:

| React                                                       | InSpatial                                                        |
| ----------------------------------------------------------- | ---------------------------------------------------------------- |
| `useState(0)`                                               | `createState({count: 0 })`                                       |
| `createEffect(() => {}, [deps])`                            | `watch(() => {})` or `createEffect(() => {})`                    |
| `{count}`                                                   | `{count}` (same for signals)                                     |
| `{`Count: ${count}`}`                                       | `{$(() => \`Count: ${count.value}\`)}`or`{t\`Count: ${count}\`}` |
| `className={isActive ? 'active' : ''}`                      | `class:active={isActive}`                                        |
| `onClick={() => {}}`                                        | `on:click={() => {}}`                                            |
| Components are functions                                    | Components return functions `(props) => JSX`                     |
| Virtual DOM re-renders                                      | Retained mode, direct DOM updates                                |
| Conditional: `{condition && <div/>}`                        | `<Show when={signal}>{() => <div/>}</Show>`                      |
| Reactive Lists: `{items.map(item => <div key={item.id}/>)}` | `<List each={items} track="id">{(item) => <div/>}</List>`        |

---

## How to use InSpatial (Kit X State)

### 1. Basic Component with State

```javascript
// ❌ React way - DON'T DO THIS
const Counter = () => {
  const [count, setCount] = useState(0);
  return <div onClick={() => setCount(count + 1)}>Count: {count}</div>;
};

// ✅ The InSpatial way - DO THIS (State)
import { createState } from "@inspatial/kit/state";

const Counter = () => {
  const counter = createState({ count: 0 });
  return () => (
    <XStack on:tap={() => counter.count.set(counter.count.peek() + 1)}>
      Count: {counter.count}
    </XStack>
  );
};
```

### 2. Conditional Rendering

```javascript
// ❌ React way - DON'T DO THIS
const App = () => {
  const [isVisible, setIsVisible] = useState(true);
  return (
    <div>
      {isVisible && <div>Visible content</div>}
      <button onClick={() => setIsVisible(!isVisible)}>Toggle</button>
    </div>
  );
};

// ✅ The InSpatial way - DO THIS (State)
import { createState } from "@inspatial/kit/state";

const App = () => {
  const ui = createState({ isVisible: true });
  return (
    <XStack>
      <Show when={ui.isVisible}>{() => <div>Visible content</div>}</Show>
      <Button on:click={() => ui.isVisible.set(!ui.isVisible.peek())}>
        Toggle
      </Button>
    </XStack>
  );
};
```

### 3. List Rendering

```javascript
// ❌ React way - DON'T DO THIS
const TodoList = () => {
  const [todos, setTodos] = useState([{ id: 1, text: "Learn React" }]);
  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
};

// ✅ The InSpatial way - DO THIS (State)
import { createState } from "@inspatial/kit/state";

const TodoList = () => {
  const state = createState({ todos: [{ id: 1, text: "Learn InSpatial" }] });
  return (
    <YStack>
      <List each={state.todos} track="id">
        {(todo) => <Text>{todo.text}</Text>}
      </List>
    </YStack>
  );
};
```

### 4. Effects and Cleanup

```javascript
// ❌ React way - DON'T DO THIS
useEffect(() => {
  const handler = () => console.log("resize");
  window.addEventListener("resize", handler);
  return () => window.removeEventListener("resize", handler);
}, []);

// ✅ The InSpatial way - DO THIS
createEffect(() => {
  createTrigger("swipe", createResizeHandler(), {
    platforms: ["dom", "native:ios", "native:android"],
    fallback: "resize",
  });
});
```

#### You Might Not Need Effect

Most “do something when the view appears/changes” use‑cases don’t need `createEffect`. Prefer lifecycle trigger props and reactive control‑flow.

- **Probability**: You're most likely to gravitate towards lifecycle trigger props (on:beforeMount/on:mount) in alongside a Control Flow component i.e <Show> on ~85% of your use cases, and most likely less than ~15% `createEffect` (subscriptions, timers, explicit side‑effects).

- What to reach for first

  - Use `on:beforeMount` or `on:mount` on a host element to run lifecycle work.
  - Use `$(() => ...)` + `Show` to reactively render based on signals/computed state.
  - Keep all listeners inside the InSpatial trigger system.

- When to use which lifecycle

  - `on:beforeMount`: synchronous during setup. Great when the initial render should already reflect a state flip.
  - `on:mount`: next tick after first paint. Use when you want post‑paint work.
  - Nuance: whether the first paint includes a `beforeMount` change depends on renderer timing; it runs during directive setup (synchronously), not deferred.

- When you actually want `createEffect`

  - Subscriptions to signals (e.g., logging, analytics, cross‑state reactions)
  - Timers/intervals tied to state, with cleanup via `onDispose`
  - Deriving non‑UI side effects from signals

- Anti‑pattern to avoid

  - Using `createEffect` as a surrogate for lifecycle: it runs immediately on setup and on subsequent signal changes, but it isn’t lifecycle‑bound and may run before mount. Prefer trigger props for mount timing.

- Recipes
  - Show content after lifecycle without effects

```tsx
import { createState, $ } from "@inspatial/kit/state";
import { Stack } from "@inspatial/kit/structure";
import { Show } from "@inspatial/kit/control-flow";

const ui = createState({ render: false });

<Stack on:beforeMount={() => ui.render.set(true)}>
  <Show when={$(() => ui.render.get())}>
    {() => <Text>This is most likely what you should be doing</Text>}
  </Show>
</Stack>;
```

- Reactive branching without effects

```tsx
import { Show } from "@inspatial/kit/control-flow";
import { $ } from "@inspatial/kit/state";
import { useTheme } from "@inspatial/kit/theme";

<Show
  when={$(() => useTheme.mode.get() === "dark")}
  otherwise={() => <LightUI />}
>
  {() => <DarkUI />}
</Show>;
```

- Side‑effect from data (this is where `createEffect` shines)

```tsx
import { createEffect } from "@inspatial/kit/state";

createEffect(() => {
  const mode = useTheme.mode.get();
  console.log("theme:", mode);
  // Return optional cleanup with onDispose inside, if needed
});
```

Bottom line: lifecycle → trigger props; reactivity → `$`/`Show`; subscriptions/side‑effects → `createEffect`.

### 5. Conditional Classes

```javascript
// ❌ React way - DON'T DO THIS
<button className={isActive ? 'btn active' : 'btn'}/>

 // ✅ The InSpatial way - DO THIS
<Button className="btn" class:active={isActive}>
```

#### Conditionally Rendering Computed/Reactive Values

##### `Show`

```typescript
// ❌  DON'T DO THIS: It wont react
<Button on:tap={() => useTheme.action.setToggle()}>
  {$(() =>
    String(useTheme.mode) === "dark" ? <LightModeIcon /> : <DarkModeIcon />
  )}
</Button>

// ✅ DO THIS
<Button
    on:tap={() => useTheme.action.setToggle()}
  >
    <Show
      when={$(() => String(useTheme.mode) === "dark")}
      otherwise={<DarkModeIcon />}
    >
      <LightModeIcon />
    </Show>
  </Button>
```

##### `Choose` - The InSpatial Switch Statement

```typescript
// ❌  DON'T DO THIS: It wont react
export function InputField() {
  return (
    <>
      {(() => {
        switch (variant) {
          case "emailfield":
            return <EmailField />;
          case "searchfield":
            return <SearchField />;
          default:
            return <TextField />;
        }
      })()}
    </>
  );
}

// ✅ DO THIS
import { Choose } from "@inspatial/kit/control-flow"
export function InputField({ variant }) {
  return (
    <>
    Choose({
    cases: [
      { when: $(() => variant.value === "emailfield"), children: EmailField },
      { when: $(() => variant.value === "searchfield"), children: SearchField },
    ],
    otherwise: TextField,
  });
   </>
  )
}
```

#### Difference Between Show & Choose

- Show and Choose are both use to react to conditional values
- Use `<Show>` where you want to display a binary value e.g [this or that]
- Use `Choose` where multi-branch logic is desired, [this, this, this and more of those]

### 6. Complex Reactive Expressions

```javascript
// ❌ React way - DON'T DO THIS
const message = `Count is: ${count}`;

// ✅ The InSpatial way - DO THIS (State)
import { createState, $ } from "@inspatial/kit/state";

const s = createState({ count: 0 });
const message = $(() => `Count is: ${s.count.get()}`);
// or inline:
<XStack>{$(() => `Count is: ${s.count.get()}`)}</XStack>;
```

### 7. Async Components

```javascript
// ✅ The InSpatial async component pattern
const PostCard = async ({ id }: PostID) => {
  const response = await fetch(`/api/story/${postId}`);
  const story = await response.json();

  return (
    <YStack className="story">
      <Text>{story.title}</Text>
      <Text>By {story.author}</Text>
    </YStack>
  );
};

// Usage with error handling
<PostCard
  id={123}
  fallback={() => <XStack>Loading...</XStack>}
  catch={({ error }) => <XStack>Error: {error.message}</XStack>}
/>;
```

### 8. State Signal Operations (Advanced)

```typescript
import { createState, $ } from "@inspatial/kit/state";

// State-backed signal comparisons and derived values
const s = createState({ count: 5, status: "loading" });
const isPositive = s.count.gt(0); // count > 0
const isZero = s.count.eq(0); // count === 0
const isEven = $(() => s.count.get() % 2 === 0);

// Derived values remain the same using $()
const label = $(() => `Status: ${s.status.get()}`);
```

### 9. Event Handling with Modifiers

```javascript
// Different event modifiers
<Button on:tap={() => console.log('normal')}>Click</Button>
<Button on-once:click={() => console.log('only once')}>Click Once</Button>
<ScrollView on-passive:scroll={() => console.log('passive scroll')}>Scrollable</ScrollView>
<Link to="#" on-prevent:click={() => console.log('prevented')}>Link</Link>
```

### 10. Template Literals for URLs

```javascript
// Template literals with reactive interpolation (State)
import { createState } from "@inspatial/kit/state";

const s = createState({ templateId: 123 });
const templateUrl = t`https://inspatial.store/template?id=${s.templateId}`;
```

## Common InSpatial Patterns

1. **Component Structure**: `const MyComponent = (props) => <JSX/>`
2. **State**: `const state = createState({ initialState })`
3. **Computed Values**: `const computed = $(() => state.value * 2)`
4. **Effects**: `watch(() => { /* reactive code */ })`
5. **Cleanup**: `createEffect(() => { /* setup */; return () => { /* cleanup */ } })`
6. **Conditional Classes**: `class:active={isActive}`
7. **Lists**: `<List each={entries}>{(entry) => <Entry data={entry}/>}</List>`
8. **Conditions**: `<Show when={isVisible}>{() => <>Visible content</>}</Show>`
9. **Async**: Components can be `async` functions with `fallback` and `catch` props
10. **Signal Operations**: Use `.eq()`, `.gt()`, `.and()`, etc. for comparisons
11. **Render**: `InSpatial.render(container, component, props, ...children)`
12. **Env**: Short for Environment `@inspatial/kit/env` built on `@in/vader/env` should be use to condition platform, runtime and render targets as well as environment variables.

### Naming Pattern

```
@(window)/
├── State Variables (useX)
│   ├── useCounter
│   ├── useTheme
│   └── useAuth
│
├── State Types (XProps)
│   ├── CounterProps
│   ├── ThemeProps
│   └── AuthProps
│
├── Action Triggers (handleX)
│   ├── handleCounter
│   └── handleAuth
│
│
└── Action Declarations (setX)
    ├── setIncrement
    ├── setToggle
    └── setReset
```

**Benefits**

- **Zero cognitive load** - developers know exactly what to expect
- **Searchable** - easy to find all states (search `use`), triggers (search `handle`), actions (search `set`)
- **Consistent** - same pattern across entire codebase
- **Maintainable** - refactoring becomes predictable

## Footguns, Anti-Patterns & Conflicts

Because InSpatial is a Universal Development Environment (UDE), there are many patterns developers are traditionally accustomed to that are now considered Anti-Patterns. These Anti-patterns sually stem from three core concept that are historically baked into frameworks. They include:

- Styling
- Triggers
- Motion

These are primary systems that are intentionally detached from InSpatial Renderer. Universal Apps are omni-platforms and as such we should never assume the environment the user is in. Detaching these concepts create a conflict-free system one that allows for a universal platform.

## First principles: keep it simple, make it reactive

- **If I make everything reactive or computed, do I need to worry about performance?**

  - **Answer**: No.
  - **Why?**: InSpatial Kit is built for interactivity, so using reactive patterns by default is generally safe and won’t cause noticeable slowdowns.

- **What “reactive” really means**

  - Values remember who cares about them. When a value changes, only the things that depend on it update.
  - If nothing changes, nothing runs. Idle cost is basically zero.

- **Signals and `$`**

  - Signals are just values you can watch. `$` makes a value that follows other values.
  - Don’t wrap hard-coded constants in `$`. Use `$` for anything that’s derived from changing state.

- **State**

  - Each field in your state is its own signal. Update one field without waking the whole app.
  - Batch multiple updates together when you can.

- **UI flow**

  - `Show`: with a plain boolean, it’s just an if/else. With a signal, it updates when that signal changes.
  - `Choose`: checks cases in order and updates when their conditions change.
  - `List`: give items a key when lists get big or reorder often.

- **Good defaults**

  - Make things reactive by default.
  - Hoist reused computeds and handlers out of tight loops.
  - Use keys for large lists; group multiple updates.

- **When to think twice**

  - Huge lists that constantly reorder → use keys, paginate, or virtualize.
  - Creating thousands of new computeds per frame → reuse instead of recreating. In other words - avoid unintended tracking and avoid creating lots of new watchers in tight loops.

- **Bottom line**
  - Reactive-by-default is safe. Work scales with what actually changes, not with app size.
