InSpatial Run is based on InSpatial's own signal reactive primitives `@in/teract`. InSpatial sematically shares sytax with the likes of React, SolidJS and Preact.

InSpatial Run is the Framework Runtime for InSpatial universal renderer `@in/renderer` which targets all platforms with support for multiple templating e.g JSX.

**Important** InSpatial Run is its own independent self-contained framework powered by its own dev modules, concept, opinions and renderers and as such IT IS IS DIFFERENT FROM REACT, SOLIDJS, PREACT or any other framework.

InSpatial Run is the highest layer of abstraction for both InSpatial dev and cloud UDE modules. All core utilities, actions and APIs are encapsulated into simpler functions and file routes essentially removing the need for any form of project initialization or configurations. InSpatial Run removes the need to install or use any of InSpatial's stand-alone dev and cloud modules as they come bundled with it by default.

### NOTE

- **THIS IS NOT A REACT PROJECT**: Do not import, write or use React apis and hooks.

- All InSpatial Dev Modules start with `@in` directive

- Build success doesn't mean no runtime issues. Check carefully if you have made any existing variables disappear during an edit, or the new variables has not been declared.

- If you want to check build errors in deno use the deno core command `deno task build` when using `InServe` renderer extension. Use `deno check` or `deno lint` too for comprehensive checks. For pnpm use `pnpm build`, do not use `pnpm dev`, as `pnpm dev` spawns a blocking dev server that never automatically exits.

## AI contribution rules (apply to every task)

1. Preserve existing code style, indentation, variable names, resource naming, and line endings; never re-format unrelated code.
2. Make the smallest possible change set that fully addresses the task; do not touch out-of-scope files.
3. Fix root causes rather than masking symptoms; avoid defensive checks unless requested.
4. Do not change public APIs or existing functionality unless required by the task.
5. Do not easily remove/change parts you don't understand. Ask users if you really want them changed.

**Important Notes for this Project:**

- **Retained Mode Rendering:** InSpatial directly manages the DOM based on state, unlike virtual DOM libraries.
- **Browser Preset:** The project specifically uses `@in/dom` an InSpatial DOM/Web renderer module which is a sibling to `@in/native` for native (iOS, Android, and VisionOS) rendering as well as `@in/gpu` for 3D & XR rendering.
- **Reactivity:** Use InSpatial primary Signal apis `signal`, `computed`/`$`, `watch`, for interactity and state management.
- **Kit:** Use InSpatial Kit control-flow primitives like `List`, and `Show`
- **InSpatial Cloud:** All datasource and backend functionality must ONLY use `@inspatial/cloud` and `@inspatial/cloud-client.
- **No 3rd Party Dependecies or NPM Packages**: MUST not install third-party packages or NPM packages. All packages must be installed from JSR and only InSpatial Dev Modules which start with `@in` or `@inspatial` directives.
- **InSpatial Serve:** All new projects MUST use InSpatial Serve and its `InServe` extension to bundle, mininify, serve, style/css transform, and hot-reload. Basically replaces the need for tools like Vite, RSPack or WebPack. Do not ever install or use those tools to Run an InSpatial App.

---

# InSpatial Run Concepts & Guide

## Styling & UI

**1. InSpatial Renderer:**

- **Extensible Architecture:** Decouples component logic from rendering environment.
- **`createRenderer(nodeOps, rendererID?)`:** Creates a custom renderer.
- **`DOMRenderer(InTriggerProp)` (`@inspatial/run/renderer/dom`):** For interactive web applications.
  _ **Triggers & Event Handling:** `on:eventName` (e.g., `on:click`). Supports modifiers like `on-once:`, `on-passive:`, `on-capture:`, `on-prevent:`, `on-stop:`.
  _ **Browser Preset Directives:** `class:className={signal}` for conditional classes, `style:property={value}` for individual styling (CSS) properties.
  \_ **Handling Dynamic HTML Content:** For inserting dynamic HTML (e.g., from APIs), prefer parsing the HTML into a `DocumentFragment` and rendering it directly within the component. This is more robust and integrates better with InSpatial's retained mode rendering than using `innerHTML` directly, which can have security implications and reconciliation challenges.

- **`NativeRenderer(InTriggerProp)` (`@inspatial/run/renderer/native`):** For interactive iOS, Android and VisionOS applications. \* \*\*Soon...

- **`GPURenderer(InTriggerProp)` (`@inspatial/run/renderer/spatial`):** For interactive 3D & XR applications. \* \*\*Soon...

**2. InSpatial Runtime (JSX):**
Built on top the universal runtime

- **Retained Mode:** JSX templates are evaluated once to build the initial UI.
- **Pragma Transform (Recommended)::** Provides maximum flexibility. Requires configuring `jsxFactory: 'R.c'` and `jsxFragment: 'R.f'` in build tools (Vite, Babel). Components receive `R` as an argument.
- **Automatic Runtime:** Easier setup, but less flexible. Configures `jsx: 'automatic'` and `jsxImportSource: 'InSpatial'`.
- **Hot Reload:** Use `InVite` extension for vite-rollup/rolldown and `InPack` for webpack/rspack client development.

**3. InSpatial Kit:**

- **Structure:** A component is a function `(props, ...children) => Node`. The inner function receives the renderer `R`.
- **Structure & Control Flow Components:**
  _ `<Show when={signal}>`: Conditional rendering. Supports `true` and `else` props. For one-off static conditions, you can use inline typescript to return the desired branch directly just like in React(but will not have reactivity).
  _ `<List each={signalOfArray} track="key" indexed={true}>`: Efficiently renders lists with reconciliation by handling all list rendering scenarios. Automatically handles static arrays and signals, eliminates need for `derivedExtract`, provides direct item access in templates. Use `track` for stable keys when data changes completely. Exposes `getItem()`, `remove()`, `clear()` methods. Template functions receive raw item data directly for clean, readable syntax.
  _ `<Async future={promise}>`: Manages asynchronous operations (pending, resolved, rejected states). `async` components automatically get `fallback` and `catch` props.
  _ **Error Handling in Asynchronous Components:** Implement robust error handling within `async` components. Utilize the `catch` prop of `<Async>` components or direct `fallback`/`catch` props on async components, and `try...catch` blocks for network requests to gracefully manage and display errors to the user.
  _ `<Dynamic is={componentOrTag}>`: Renders a component or HTML tag that can change dynamically.
  _ `<Fn ctx={value} catch={errorHandler}>`: Executes a function that returns a render function, useful for complex logic with error boundaries. \* **List Management:** Use `List` component's exposed methods (`getItem()`, `remove()`, `clear()`) for imperative list manipulation when needed.

- **`$ref`:** Special prop to get a reference to a DOM element or component instance (as a signal or function). **Critical for hot reload in dev mode:** always use `$ref` for component references, not `createComponent()` return values.
- **`expose()`:** Allows child components to expose properties/methods to their parent via `$ref`.
- **`capture()`:** Captures the current rendering context, useful for running functions (e.g., `expose()`) after `await` calls in async components.
- **Importing:** All built-in components can be imported directly from package `InSpatial`
- **`createComponent(template, props?, ...children)`:** Creates component instances
  **`renderer.render(container, component, props, ...children)`:** Renders a component into a container, with optional props and children.
  **`dispose(instance)`:** Cleans up component resources
  **`getCurrentSelf()`:** Gets current component instance
  **`snapshot()`:** Creates context snapshots for async operations
- **JSX Children in Control Flow Components:** When using components like `<Show>` and `<List>`, ensure their render function children return either a _single root element_ or a `Fragment` (`<>...</>`) if rendering multiple sibling elements. This prevents unexpected rendering issues.

**6. InSpatial Styling:**
InSpatial Style Sheet (ISS) or `@inspatial/style` is built on InSpatial's `@in/style`module a variant based styling engine largely inspired by Stiches.

Don’t use peek()/get() inside style objects. Pass the Signals directly so the renderer can subscribe.

Example

```typescript
// Function
const my = {
  textColor: $(() => {...}),
}

// Render
<Component
 style={{
    web: {
      // ❌  DON'T DO THIS
      color: my.textColor.get(),

      // ✅ DO THIS
      color: my.textColor,
    },
  }}
/>
```

You can style using two props `style` and `className` which is an alias for `class` (they both work just the same).

NOTE:

1. both `style` and (`className` or `class`) are reactive at the core. This means you don't have to parse computed/$ to...

2. Template strings are non-reactive. A plain backtick string evaluates once, so it can’t auto‑update. Use the object/array forms (or a Signal) for reactivity.

```typescript
// ❌  DON'T DO THIS
<Component
  className={`p-4 rounded-lg mb-4 transition-all duration-300 ${
    signal.isPulseActive ? "animate-pulse" : ""
  } ${
    signal.isHighCount
      ? "scale-110 bg-gradient-to-r from-purple-500 to-pink-500"
      : ""
  }`}
/>

// ✅ DO THIS
<Component
className={{
    "p-4": true,
    "rounded-lg": true,
    "mb-4": true,
    "transition-all": true,
    "duration-300": true,
    "animate-pulse": signal.isPulseActive,
    "scale-110 bg-gradient-to-r from-purple-500 to-pink-500":
      testSignals.isHighCount,
  }}
/>
```

#### Styling Alternative (Not-recommended)

Subsequently styling can be done by calling multiple style props e.g

```typescript
<Component
  style:color="black"
  style:background-color="yellow"
  style:font-size="20px"
/>
```

- **Styling Dynamic Elements:** For dynamically styled elements, leverage InSpatial's browser preset capabilities for conditional classes (`class:active={signal}`) and inline styles (`style:property={value}`) to ensure styles update correctly with state changes. \* \*\*Soon...

## Interactivity

### 1. Signals (@in/teract/signal)

InSpatial Run is fundamentally reactive signal based system. The core signal primitives InSpatial State is that `@in/teract` is an signal based interactivity and state management system. It is subdivided into two types of reactive systems. There is Signal Core and Signal Lite each inspired by SolidJS and Preact respectively.

- **Definition:** Reactive containers (`createSignal()`) that notify observers on value changes.
- **Computed Signals:** Derive values from other signals (`computed()`, or `$(...)` alias) and update automatically.
- **Effects:** Functions (`watch()` or `createEffect()`) that re-run when their signal dependencies change.
- **Access:** Use `.value` for read/write. `peek()` reads without creating dependencies.
- **Signal Batching:** Updates are automatically batched - effects only run once per tick.
- **Important:** In JSX, dynamic expressions depending on signals _must_ be wrapped in `$(...)` to be reactive (e.g., `$(() => \`Count: ${count.value}\`)`). Simple signal references like `{count}` are automatically handled.
- **One-off combined condition:** You don't need to wrap static combined conditions in `$(...)` if they're only used one-off, and don't change in the future. Like when a condition doesn't include any signal dependencies.

**Signal Operations:**
Use the extensive signal operation methods (`.and()`, `.eq()`, `.gt()`, etc.) for cleaner conditional logic instead of complex computed signals.

- **Utility Functions:** `read()`, `write()`, `readAll()`, `poke()`, `touch()` for safe signal manipulation
- **Logical Operations:** `.and()`, `.or()`, `.andNot()`, `.orNot()`, `.inverse()`, `.inverseAnd()`, etc.
- **Comparisons:** `.eq()`, `.neq()`, `.gt()`, `.lt()`
- **Conditional:** `.nullishThen()`, `.hasValue()`
- **Advanced:** `merge()`, `derive()`, `extract()`, `tpl\`...\``, `not()`, `onCondition()`

**Best Practices:**

- Create renderer instances **once** at the application entry point.
- Use computed signals (`$()`) for derived data and reactive expressions in JSX.
- Dispose of effects when no longer needed (`dispose()` from `watch()`, or `onDispose()`).
- Use `peek()` to avoid creating unnecessary dependencies.
- Updates are automatically batched.
- Use `untrack()` for non-reactive operations.
- Use `watch()` for effects without returning cleanup functions.
- `createEffect()` handles cleanup automatically and passes additional arguments to the effect.
- Always use `$ref` for component references in development with Hot Reaload.
- **State Management:** For complex applications, consider managing state outside of your components and passing it down as props. This promotes better separation of concerns.
- **Manual Triggering:** When mutating arrays or objects directly, use `.trigger()` to notify InSpatial of the change.
- **Focus Management:** Use the `$ref` prop with a `setTimeout` to reliably manage focus on elements, especially after asynchronous operations.
- **Template Literals:** Use `tpl\`...\`` for reactive template strings or the simple template literal \`...\` for string interpolation in URLs.
- **Reactivity Pitfalls:** Remember to wrap expressions in `$(...)` within JSX when they need to be reactive. Be mindful of when to use `peek()` or `untrack()` to control signal dependencies and avoid unnecessary re-renders.
- **Auto Coercion:**
  `.get()` is auto-coerced e.g if you have a value `signal.count` it would auto append or use `.get()` hence making it the same as `signal.count.get()`.
  While `.get()` is the default appended value you can opt out because `.get()` assumes your function is reactive by default and that may not always be the case, if this is not the case and you want to avoid tracking or create dependencies in imperative `.set()` calls, then use `.peek()`. Also don't be a stranger and utilize all the other available interactive signal operators at your disposal for their appropriate use case.

NOTE: hasValue returns plain boolean. Returns true when the value of the signal is not nullish.

### 2. InSpatial State (@inspatial/state)

InSpatial State is built-in state management system for InSpatial Run. InSpatial State provides a higher-level abstraction built on top of InSpatial's reactive signal module `@in/teract/signal`.

You can use InSpatial State in two ways:

- Explicit pattern: everything in one place via `createState.in()`
- Separation pattern: compose `createState`, `createAction`, `createStorage`

Key capabilities: batch, reset, snapshot, subscribe, derived values, and a unified trigger API.

#### Explicit pattern (recommended)

```ts
const counterState = createState.in({
  initialState: { count: 0, name: "user" },
  action: {
    increment: { key: "count", fn: (c, n = 1) => c + n },
    setName: { key: "name", fn: (_, name: string) => name },
  },
  storage: { key: "counterState", backend: "local" },
});

counterState.action.increment();
counterState.count.get();
```

#### Separation pattern (advanced)

```ts
const gameState = createState({ x: 0, y: 0, hp: 100, score: 0 });

// Direct signal trigger
const addScore = createAction(gameState.score, (s, n = 1) => s + n);

// Tuple trigger
const damage = createAction([gameState, "hp"], (hp, amt = 10) =>
  Math.max(0, hp - amt)
);

// Batch triggers
const move = createAction(gameState, {
  moveX: { key: "x", fn: (x, dx: number) => x + dx },
  moveY: { key: "y", fn: (y, dy: number) => y + dy },
});

// Optional persistence
createStorage(gameState, {
  key: "gameState",
  backend: "local",
  include: ["hp", "score"],
});
```

#### Feature snippets

- Signals on every key
  ```ts
  const s = createState({ a: 1, b: 2 });
  s.a.set(3);
  s.b.get();
  ```
- Batch/reset/snapshot/subscribe
  ```ts
  s.batch((v) => {
    v.a.set(10);
    v.b.set(20);
  });
  s.reset();
  s.snapshot();
  const off = s.subscribe((snap) => console.log(snap));
  off();
  ```
- Derived values
  ```ts
  const score2x = $(() => gameState.score.get() * 2);
  ```
- Trigger options
  ```ts
  const inc = createAction(s.a, (v) => v + 1, { throttle: 50, once: false });
  ```

#### Choosing InSpatial State Pattern

Is this a module or extension?
├── Yes → Use Separation Pattern  
└── No → Use Explicit Pattern

Is this an app or website?
├── No → Use Separation Pattern
└── Yes → Use Explicit Pattern

Is this a game or xr?
├── Yes → Use Separation Pattern
└── No → Use Explicit Pattern

Both patterns have the same power... pick the ergonomics that fit the job.

### 3. InSpatial Triggers (Props Registry)

InSpatial Triggers are grouped into `Props` and `Actions`.

- **Trigger Props**: declarative, platform-bridged event/directive attributes like `on:tap`, `style:*`, `class:*` resolved by the renderer via an extension-backed registry.
- **Action Triggers**: imperative state mutations via `createAction()` (covered in State section).

**NOTE**

- Trigger Props are disabled by default. Install the `InTriggerProp` extension to enable resolution of `on:*`, `style:*`, and `class:*`.
- Use `createTriggerHandle()` to register new or override existing trigger props in the registry.
- Import surface for trigger props is provided by `@inspatial/state`:
  ```ts
  import { InTriggerProp, createTriggerHandle } from "@inspatial/trigger";
  ```

#### Trigger (Actions)

Action triggers are part of State (see InSpatial State). Use `createAction()` for direct, tuple, or batch state updates.

#### Trigger (Props)

- Triggers are decoupled and disabled by default. The trigger prop registry helps create and mix different platform trigger props e.g you can unify the click event from web/dom and android, ios etc... give it a simple name e.g `tap` then all of those platforms will respond to the tap.
- Use `InTriggerProp` (or custom extensions) to enable triggers props.
- Use `createTriggerHandle` to register a new trigger prop e.g `on:dooropen`

#### Trigger Prop Extension

Enable trigger props by installing `InTriggerProp` in your renderer. This extension:

- Registers standard DOM events (click, input, keydown, etc.)
- Registers universal props (`tap`, `longpress`, `change`, `submit`, `focus`)
- Wires `style:*` and `class:*` for reactive styling

```typescript
import { createRenderer } from "@inspatial/renderer";
import { InTriggerProp } from "@inspatial/trigger";

createRenderer({
  mode: "auto",
  extensions: [InTriggerProp],
});
```

#### How Triggers Props Work Now

1. **JSX Compilation**: `<button on:click={handler} />` compiles to props object
2. **Renderer Processing**: Renderer calls `setProps(node, props)`
3. **Extension Routing**: `onDirective` callback routes `on:` prefixes to trigger system
4. **Trigger Handler**: `withTriggerProps.onTriggerProp` returns appropriate handler
5. **Event Binding**: Handler binds event to DOM/platform API

#### Creating New Trigger Props

Register custom trigger props via the registry. Handlers receive the `node` and the prop `value` (function or signal):

```typescript
import { createTriggerHandle } from "@inspatial/state";

// Example: basic hover state callback
createTriggerHandle("hover", (node, cb?: (e: Event) => void) => {
  if (!cb) return;
  const enter = (e: Event) => cb({ ...(e as any), type: "hoverenter" });
  const leave = (e: Event) => cb({ ...(e as any), type: "hoverleave" });
  node.addEventListener("mouseenter", enter);
  node.addEventListener("mouseleave", leave);
});

// Example: swipe with pointer events
createTriggerHandle(
  "swipe",
  (node, cb?: (e: { type: string; dx: number }) => void) => {
    if (!cb) return;
    let startX = 0;
    const down = (e: PointerEvent) => (startX = e.clientX);
    const up = (e: PointerEvent) =>
      cb({ type: "swipe", dx: e.clientX - startX });
    node.addEventListener("pointerdown", down);
    node.addEventListener("pointerup", up);
  }
);
```

#### Trigger Prop Platform-Specific Considerations

Different platforms can have different trigger implementations:

- **DOM**: Uses `addEventListener`
- **XR**: Can use spatial input APIs
- **Native**: Can use platform-specific gesture recognizers
  etc...

The trigger bridge system handles these differences transparently. `InTriggerProp` auto-registers a universal bridge so `on:tap` maps to `click` on the web, and `longpress` is synthesized from pointer events.

**.4. InSpatial Motion:**
InSpatial Motion is built on InSpatial's `@in/motion`. \* \*\*Soon...

#### NOTE On Interactivity

NOTE: Signals are the most low-level reactive primitives you should only ever use `createSignal()` API from `@in/teract/signal` directly only when building frameworks. Otherwise application development MUST use `createState()` api from `@inspatial/state` which builds upon signals.

## Routing & Navigation

**.7. InSpatial Route:**
InSpatial Route is built on InSpatial's `@in/route` module. \* \*\*Soon...

## Testing

**.8. InSpatial Test:**
InSpatial Test is built on InSpatial's `@in/test`. \* \*\*Soon...

## Cloud & Backend

**.9. InSpatial Cloud:**
InSpatial Cloud is built on `@inspatial/cloud` and exposes `@inspatial/cloud` APIs for comprehensive backend and data management across all platforms. \* \*\*Soon...

---

## InSpatial Documentation Reference

**Core Signal APIs:**

- `createSignal(value)`, `computed(fn)`, `$(fn)` - Creating signals
- `watch(effect)`, `createEffect(effect, ...args)` - Effects with lifecycle
- `read(value)`, `write(signal, value)`, `peek(value)`, `poke(signal, value)` - Utilities
- Signal methods: `.and()`, `.or()`, `.eq()`, `.gt()`, `.inverse()`, `.nullishThen()`, `.hasValue()`
- Advanced: `merge()`, `derive()`, `extract()`, `tpl\`...\``, `not()`, `onCondition()`

Note: hasValue returns plain boolean. Returns true when the value of the signal is not nullish.

**Component (Kit) APIs:**

- `createComponent()`, `web.render(container, component, props, ...children)`, `dispose()` - Component lifecycle
- `expose()`, `capture()`, `snapshot()`, `getCurrentSelf()` - Context management
- `onDispose()` - Cleanup registration

**Built-in Components:**

- `<Show when={} true={} else={}>` - Conditional rendering
- `<List each={} track="" indexed={}>` - List rendering with reconciliation (Direct item access, auto-handles arrays/signals)
- `<Async future={} fallback={} catch={}>` - Promise handling
- `<Dynamic is={}>` - Dynamic component/tag rendering
- `<Fn ctx={} catch={}>` - Function execution with error boundaries

**Renderer Setup:**

- `DOMRenderer(InTriggerProp)` from `@in/dom`
- `InTriggerProp` from `@inspatial/run/trigger` to ship the default/core web props i.e `class:` and `style:`
- Trigger system & Event handling: `on:event`, `on-once:event`, `on-passive:event`, `on-capture:event`

**JSX Configuration**

## Globally defined JSX Runtime for Deno

JSX runtime is essential when using InSpatial together with runtimes like [Deno](https://github.com/denoland/deno/issues/29584), compilers like [SWC](https://github.com/swc-project/swc/issues/10553) or generators like [MDX](https://mdxjs.com/), since they lack the ability to correctly transform JSX via parameters.

### Setup with (@Inspatial/serve) Renderer Extensions

```typescript
// render.ts
import { createRenderer } from "@inspatial/run/renderer";
import { InServe } from "@inspatial/serve";

createRenderer({
  extensions: [InServe],
});
```

Then add your deno.json

```json
//deno.json
{
  "tasks": {
    "serve": "deno run --allow-net --allow-read --allow-write --allow-env --allow-run src/config/render.ts"
  }
}
```

### Setup with a build tool (Alternative)

Your setup can be configured too build tool like (Vite, Rollup with Babel, Rspack or Webpack) to use InSpatial's JSX runtime.

#### Vite (`vite.config.ts`)

##### Pragma Config (Default)

```typescript
import { defineConfig } from "vite";
import tailwindcss from "@tailwindcss/vite";
import deno from "@deno/vite-plugin";
import { InSpatial } from "@inspatial/run/hot";

export default defineConfig({
  server: {
    port: 6310,
  },
  esbuild: {
    jsxFactory: "R.c",
    jsxFragment: "R.f",
  },
  plugins: [
    deno(),
    tailwindcss(), // Optional
    InVite(),
  ],
  build: {
    target: "esnext",
  },
});
```

##### Automatic Config

```typescript
import { defineConfig } from "vite";

export default defineConfig({
  esbuild: {
    jsx: "automatic",
    jsxImportSource: "@inspatial/run", // This tells Vite/esbuild where to find the runtime
  },
});
```

#### Babel (`.babelrc.json`)

```json
{
  "presets": [
    [
      "@babel/preset-react",
      {
        "runtime": "automatic",
        "importSource": "@inspatial/run"
      }
    ]
  ]
}
```

### Initialization

Once your build tool is configured, you need to initialize the runtime with a renderer in your application's entry point. There are two ways you can configure the renderer.

#### Automatic Render (Preferred)

```typescript
import "./kit.css";
import { createRenderer } from "@inspatial/run/renderer";
import { App } from "../my/app/root.tsx";

// Create InSpatial renderer with Trigger Props
createRenderer({
  mode: "auto",
  debug: "verbose",
  extensions: [InTriggerProp],
}).then((InSpatial: any) => {
  InSpatial.render(document.getElementById("app"), App);
});
```

Now, any `.jsx` or `.tsx` file will be automatically transformed to use the initialized runtime, so you don't need any special imports to write JSX.

**Hot Reload:**

#### Vite

```javascript
import { defineConfig } from "vite";
import InSpatial from "@inspatial/run/hot";

export default defineConfig({
  plugins: [InVite()],
  // ... jsx config
});
```

#### Rspack (RsBuild) or Webpack

```javascript
import { defineConfig } from "@rsbuild/core";
import InSpatialRun from "@inspatial/run/hot";

export default defineConfig({
  plugins: [InPack()],
  // ... jsx config
});
```

---

## ⚠️ CRITICAL: THIS IS NOT REACT!

**DO NOT write React code in this project.** InSpatial has fundamentally different patterns:

### Key Differences from React:

| React                                                       | InSpatial                                                        |
| ----------------------------------------------------------- | ---------------------------------------------------------------- |
| `useState(0)`                                               | `createSignal(0)`                                                |
| `createEffect(() => {}, [deps])`                            | `watch(() => {})` or `createEffect(() => {})`                    |
| `{count}`                                                   | `{count}` (same for signals)                                     |
| `{`Count: ${count}`}`                                       | `{$(() => \`Count: ${count.value}\`)}`or`{t\`Count: ${count}\`}` |
| `className={isActive ? 'active' : ''}`                      | `class:active={isActive}`                                        |
| `onClick={() => {}}`                                        | `on:click={() => {}}`                                            |
| Components are functions                                    | Components return functions `(props) => JSX`                     |
| Virtual DOM re-renders                                      | Retained mode, direct DOM updates                                |
| Conditional: `{condition && <div/>}`                        | `<Show when={signal}>{() => <div/>}</Show>`                      |
| Reactive Lists: `{items.map(item => <div key={item.id}/>)}` | `<List each={items} track="id">{(item) => <div/>}</List>`        |

---

## How to use InSpatial (Kit X State)

### 1. Basic Component with State

```javascript
// ❌ React way - DON'T DO THIS
const Counter = () => {
  const [count, setCount] = useState(0);
  return <div onClick={() => setCount(count + 1)}>Count: {count}</div>;
};

// ✅ The InSpatial way - DO THIS (State)
import { createState } from "@inspatial/state";

const Counter = () => {
  const counter = createState({ count: 0 });
  return () => (
    <XStack on:tap={() => counter.count.set(counter.count.peek() + 1)}>
      Count: {counter.count}
    </XStack>
  );
};
```

### 2. Conditional Rendering

```javascript
// ❌ React way - DON'T DO THIS
const App = () => {
  const [isVisible, setIsVisible] = useState(true);
  return (
    <div>
      {isVisible && <div>Visible content</div>}
      <button onClick={() => setIsVisible(!isVisible)}>Toggle</button>
    </div>
  );
};

// ✅ The InSpatial way - DO THIS (State)
import { createState } from "@inspatial/state";

const App = () => {
  const ui = createState({ isVisible: true });
  return (
    <XStack>
      <Show when={ui.isVisible}>{() => <div>Visible content</div>}</Show>
      <Button on:click={() => ui.isVisible.set(!ui.isVisible.peek())}>
        Toggle
      </Button>
    </XStack>
  );
};
```

### 3. List Rendering

```javascript
// ❌ React way - DON'T DO THIS
const TodoList = () => {
  const [todos, setTodos] = useState([{ id: 1, text: "Learn React" }]);
  return (
    <ul>
      {todos.map((todo) => (
        <li key={todo.id}>{todo.text}</li>
      ))}
    </ul>
  );
};

// ✅ The InSpatial way - DO THIS (State)
import { createState } from "@inspatial/state";

const TodoList = () => {
  const state = createState({ todos: [{ id: 1, text: "Learn InSpatial" }] });
  return (
    <YStack>
      <List each={state.todos} track="id">
        {(todo) => <Text>{todo.text}</Text>}
      </List>
    </YStack>
  );
};
```

### 4. Effects and Cleanup

```javascript
// ❌ React way - DON'T DO THIS
useEffect(() => {
  const handler = () => console.log("resize");
  window.addEventListener("resize", handler);
  return () => window.removeEventListener("resize", handler);
}, []);

// ✅ The InSpatial way - DO THIS
createEffect(() => {
  createTriggerHandle("swipe", createResizeHandler(), {
    platforms: ["dom", "native:ios", "native:android"],
    fallback: "resize",
  });
});
```

### 5. Conditional Classes

```javascript
// ❌ React way - DON'T DO THIS
<button className={isActive ? 'btn active' : 'btn'}/>

 // ✅ The InSpatial way - DO THIS
<Button className="btn" class:active={isActive}>
```

### 6. Complex Reactive Expressions

```javascript
// ❌ React way - DON'T DO THIS
const message = `Count is: ${count}`;

// ✅ The InSpatial way - DO THIS (State)
import { createState, $ } from "@inspatial/state";

const s = createState({ count: 0 });
const message = $(() => `Count is: ${s.count.get()}`);
// or inline:
<XStack>{$(() => `Count is: ${s.count.get()}`)}</XStack>;
```

### 7. Async Components

```javascript
// ✅ The InSpatial async component pattern
const PostCard = async ({ id }: PostID) => {
  const response = await fetch(`/api/story/${postId}`);
  const story = await response.json();

  return (
    <YStack className="story">
      <Text>{story.title}</Text>
      <Text>By {story.author}</Text>
    </YStack>
  );
};

// Usage with error handling
<PostCard
  id={123}
  fallback={() => <XStack>Loading...</XStack>}
  catch={({ error }) => <XStack>Error: {error.message}</XStack>}
/>;
```

### 8. State Signal Operations (Advanced)

```typescript
import { createState, $ } from "@inspatial/state";

// State-backed signal comparisons and derived values
const s = createState({ count: 5, status: "loading" });
const isPositive = s.count.gt(0); // count > 0
const isZero = s.count.eq(0); // count === 0
const isEven = $(() => s.count.get() % 2 === 0);

// Derived values remain the same using $()
const label = $(() => `Status: ${s.status.get()}`);
```

### 9. Event Handling with Modifiers

```javascript
// Different event modifiers
<Button on:tap={() => console.log('normal')}>Click</Button>
<Button on-once:click={() => console.log('only once')}>Click Once</Button>
<ScrollView on-passive:scroll={() => console.log('passive scroll')}>Scrollable</ScrollView>
<Link to="#" on-prevent:click={() => console.log('prevented')}>Link</Link>
```

### 10. Template Literals for URLs

```javascript
// Template literals with reactive interpolation (State)
import { createState } from "@inspatial/state";

const s = createState({ templateId: 123 });
const templateUrl = t`https://inspatial.store/template?id=${s.templateId}`;
```

## Common InSpatial Patterns

1. **Component Structure**: `const MyComponent = (props) => <JSX/>`
2. **State**: `const state = createState({ initialState })`
3. **Computed Values**: `const computed = $(() => state.value * 2)`
4. **Effects**: `watch(() => { /* reactive code */ })`
5. **Cleanup**: `createEffect(() => { /* setup */; return () => { /* cleanup */ } })`
6. **Conditional Classes**: `class:active={isActive}`
7. **Lists**: `<List each={entries}>{(entry) => <Entry data={entry}/>}</List>`
8. **Conditions**: `<Show when={isVisible}>{() => <>Visible content</>}</Show>`
9. **Async**: Components can be `async` functions with `fallback` and `catch` props
10. **Signal Operations**: Use `.eq()`, `.gt()`, `.and()`, etc. for comparisons
11. **Render**: `InSpatial.render(container, component, props, ...children)`
    `

### Naming Pattern

```
@(window)/
├── State Variables (useX)
│   ├── useCounter
│   ├── useTheme
│   └── useAuth
│
├── State Types (XProps)
│   ├── CounterProps
│   ├── ThemeProps
│   └── AuthProps
│
├── Action Triggers (handleX)
│   ├── handleCounter
│   └── handleAuth
│
│
└── Action Declarations (setX)
    ├── setIncrement
    ├── setToggle
    └── setReset
```

**Benefits**

- **Zero cognitive load** - developers know exactly what to expect
- **Searchable** - easy to find all states (search `use`), triggers (search `handle`), actions (search `set`)
- **Consistent** - same pattern across entire codebase
- **Maintainable** - refactoring becomes predictable
